// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.3
// - protoc             v5.29.2
// source: image/v1/image.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationImageServiceImageHistory = "/image.v1.ImageService/ImageHistory"
const OperationImageServiceInspectImage = "/image.v1.ImageService/InspectImage"
const OperationImageServiceListImages = "/image.v1.ImageService/ListImages"
const OperationImageServiceLoadImage = "/image.v1.ImageService/LoadImage"
const OperationImageServicePullImage = "/image.v1.ImageService/PullImage"
const OperationImageServicePushImage = "/image.v1.ImageService/PushImage"
const OperationImageServiceRemoveImage = "/image.v1.ImageService/RemoveImage"
const OperationImageServiceSaveImage = "/image.v1.ImageService/SaveImage"
const OperationImageServiceTagImage = "/image.v1.ImageService/TagImage"

type ImageServiceHTTPServer interface {
	// ImageHistory Show image history (equivalent to nerdctl history)
	ImageHistory(context.Context, *ImageHistoryRequest) (*ImageHistoryResponse, error)
	// InspectImage Get image details (equivalent to nerdctl inspect on images)
	InspectImage(context.Context, *InspectImageRequest) (*InspectImageResponse, error)
	// ListImages List images (equivalent to nerdctl images)
	ListImages(context.Context, *ListImagesRequest) (*ListImagesResponse, error)
	// LoadImage Load images from tar archive (equivalent to nerdctl load)
	LoadImage(context.Context, *LoadImageRequest) (*LoadImageResponse, error)
	// PullImage Pull an image (equivalent to nerdctl pull)
	PullImage(context.Context, *PullImageRequest) (*PullImageResponse, error)
	// PushImage Push an image (equivalent to nerdctl push)
	PushImage(context.Context, *PushImageRequest) (*PushImageResponse, error)
	// RemoveImage Remove images (equivalent to nerdctl rmi)
	RemoveImage(context.Context, *RemoveImageRequest) (*RemoveImageResponse, error)
	// SaveImage Save images to tar archive (equivalent to nerdctl save)
	SaveImage(context.Context, *SaveImageRequest) (*SaveImageResponse, error)
	// TagImage Tag an image (equivalent to nerdctl tag)
	TagImage(context.Context, *TagImageRequest) (*TagImageResponse, error)
}

func RegisterImageServiceHTTPServer(s *http.Server, srv ImageServiceHTTPServer) {
	r := s.Route("/")
	r.GET("/v1/images", _ImageService_ListImages0_HTTP_Handler(srv))
	r.POST("/v1/images/pull", _ImageService_PullImage0_HTTP_Handler(srv))
	r.POST("/v1/images/push", _ImageService_PushImage0_HTTP_Handler(srv))
	r.DELETE("/v1/images/{name}", _ImageService_RemoveImage0_HTTP_Handler(srv))
	r.POST("/v1/images/{source_image}/tag", _ImageService_TagImage0_HTTP_Handler(srv))
	r.POST("/v1/images/save", _ImageService_SaveImage0_HTTP_Handler(srv))
	r.POST("/v1/images/load", _ImageService_LoadImage0_HTTP_Handler(srv))
	r.GET("/v1/images/{name}/history", _ImageService_ImageHistory0_HTTP_Handler(srv))
	r.GET("/v1/images/{name}/inspect", _ImageService_InspectImage0_HTTP_Handler(srv))
}

func _ImageService_ListImages0_HTTP_Handler(srv ImageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListImagesRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageServiceListImages)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListImages(ctx, req.(*ListImagesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListImagesResponse)
		return ctx.Result(200, reply)
	}
}

func _ImageService_PullImage0_HTTP_Handler(srv ImageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in PullImageRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageServicePullImage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.PullImage(ctx, req.(*PullImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*PullImageResponse)
		return ctx.Result(200, reply)
	}
}

func _ImageService_PushImage0_HTTP_Handler(srv ImageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in PushImageRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageServicePushImage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.PushImage(ctx, req.(*PushImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*PushImageResponse)
		return ctx.Result(200, reply)
	}
}

func _ImageService_RemoveImage0_HTTP_Handler(srv ImageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in RemoveImageRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageServiceRemoveImage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.RemoveImage(ctx, req.(*RemoveImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*RemoveImageResponse)
		return ctx.Result(200, reply)
	}
}

func _ImageService_TagImage0_HTTP_Handler(srv ImageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in TagImageRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageServiceTagImage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.TagImage(ctx, req.(*TagImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*TagImageResponse)
		return ctx.Result(200, reply)
	}
}

func _ImageService_SaveImage0_HTTP_Handler(srv ImageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in SaveImageRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageServiceSaveImage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.SaveImage(ctx, req.(*SaveImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*SaveImageResponse)
		return ctx.Result(200, reply)
	}
}

func _ImageService_LoadImage0_HTTP_Handler(srv ImageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in LoadImageRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageServiceLoadImage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.LoadImage(ctx, req.(*LoadImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*LoadImageResponse)
		return ctx.Result(200, reply)
	}
}

func _ImageService_ImageHistory0_HTTP_Handler(srv ImageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ImageHistoryRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageServiceImageHistory)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ImageHistory(ctx, req.(*ImageHistoryRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ImageHistoryResponse)
		return ctx.Result(200, reply)
	}
}

func _ImageService_InspectImage0_HTTP_Handler(srv ImageServiceHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in InspectImageRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationImageServiceInspectImage)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.InspectImage(ctx, req.(*InspectImageRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*InspectImageResponse)
		return ctx.Result(200, reply)
	}
}

type ImageServiceHTTPClient interface {
	ImageHistory(ctx context.Context, req *ImageHistoryRequest, opts ...http.CallOption) (rsp *ImageHistoryResponse, err error)
	InspectImage(ctx context.Context, req *InspectImageRequest, opts ...http.CallOption) (rsp *InspectImageResponse, err error)
	ListImages(ctx context.Context, req *ListImagesRequest, opts ...http.CallOption) (rsp *ListImagesResponse, err error)
	LoadImage(ctx context.Context, req *LoadImageRequest, opts ...http.CallOption) (rsp *LoadImageResponse, err error)
	PullImage(ctx context.Context, req *PullImageRequest, opts ...http.CallOption) (rsp *PullImageResponse, err error)
	PushImage(ctx context.Context, req *PushImageRequest, opts ...http.CallOption) (rsp *PushImageResponse, err error)
	RemoveImage(ctx context.Context, req *RemoveImageRequest, opts ...http.CallOption) (rsp *RemoveImageResponse, err error)
	SaveImage(ctx context.Context, req *SaveImageRequest, opts ...http.CallOption) (rsp *SaveImageResponse, err error)
	TagImage(ctx context.Context, req *TagImageRequest, opts ...http.CallOption) (rsp *TagImageResponse, err error)
}

type ImageServiceHTTPClientImpl struct {
	cc *http.Client
}

func NewImageServiceHTTPClient(client *http.Client) ImageServiceHTTPClient {
	return &ImageServiceHTTPClientImpl{client}
}

func (c *ImageServiceHTTPClientImpl) ImageHistory(ctx context.Context, in *ImageHistoryRequest, opts ...http.CallOption) (*ImageHistoryResponse, error) {
	var out ImageHistoryResponse
	pattern := "/v1/images/{name}/history"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationImageServiceImageHistory))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ImageServiceHTTPClientImpl) InspectImage(ctx context.Context, in *InspectImageRequest, opts ...http.CallOption) (*InspectImageResponse, error) {
	var out InspectImageResponse
	pattern := "/v1/images/{name}/inspect"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationImageServiceInspectImage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ImageServiceHTTPClientImpl) ListImages(ctx context.Context, in *ListImagesRequest, opts ...http.CallOption) (*ListImagesResponse, error) {
	var out ListImagesResponse
	pattern := "/v1/images"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationImageServiceListImages))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ImageServiceHTTPClientImpl) LoadImage(ctx context.Context, in *LoadImageRequest, opts ...http.CallOption) (*LoadImageResponse, error) {
	var out LoadImageResponse
	pattern := "/v1/images/load"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationImageServiceLoadImage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ImageServiceHTTPClientImpl) PullImage(ctx context.Context, in *PullImageRequest, opts ...http.CallOption) (*PullImageResponse, error) {
	var out PullImageResponse
	pattern := "/v1/images/pull"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationImageServicePullImage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ImageServiceHTTPClientImpl) PushImage(ctx context.Context, in *PushImageRequest, opts ...http.CallOption) (*PushImageResponse, error) {
	var out PushImageResponse
	pattern := "/v1/images/push"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationImageServicePushImage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ImageServiceHTTPClientImpl) RemoveImage(ctx context.Context, in *RemoveImageRequest, opts ...http.CallOption) (*RemoveImageResponse, error) {
	var out RemoveImageResponse
	pattern := "/v1/images/{name}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationImageServiceRemoveImage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ImageServiceHTTPClientImpl) SaveImage(ctx context.Context, in *SaveImageRequest, opts ...http.CallOption) (*SaveImageResponse, error) {
	var out SaveImageResponse
	pattern := "/v1/images/save"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationImageServiceSaveImage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ImageServiceHTTPClientImpl) TagImage(ctx context.Context, in *TagImageRequest, opts ...http.CallOption) (*TagImageResponse, error) {
	var out TagImageResponse
	pattern := "/v1/images/{source_image}/tag"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationImageServiceTagImage))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
